import time
import re
import openai
import sys
import os
from dotenv import load_dotenv
import random
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import TimeoutException


def interact_with_tweet(wait):
    # Get the first tweet in the timeline
    tweet = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'article[data-testid="tweet"]')))

    # Like the tweet
    like_button = tweet.find_element(By.CSS_SELECTOR, 'div[data-testid="like"]')
    time.sleep(random.uniform(1, 3))  # Random pause for human-like behavior
    like_button.click()

    # Retweet the tweet
    retweet_button = tweet.find_element(By.CSS_SELECTOR, 'div[data-testid="retweet"]')
    time.sleep(random.uniform(1, 3))  # Random pause for human-like behavior
    retweet_button.click()

    # Confirm the retweet in the popup
    confirm_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'div[data-testid="retweetConfirm"]')))
    confirm_button.click()

    # Reply to the tweet
    reply_button = tweet.find_element(By.CSS_SELECTOR, 'div[data-testid="reply"]')
    time.sleep(random.uniform(1, 3))  # Random pause for human-like behavior
    reply_button.click()

    # Wait for the reply textarea to appear and fill in a message generated by GPT-3
    reply_textarea = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'div[role="textbox"]')))
    tweet_text = tweet.find_element(By.CSS_SELECTOR, 'div[data-testid="tweetText"]').text
    prompt = f"The tweet is: \"{tweet_text}\". What would be a suitable response?"
    response = openai.Completion.create(engine="text-davinci-002", prompt=prompt, max_tokens=60)
    reply = response.choices[0].text.strip()
    reply_textarea.send_keys(reply)
    time.sleep(random.uniform(1, 3))  # Random pause for human-like behavior

    # Submit the reply
    tweet_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'div[data-testid="tweetButton"]')))
    tweet_button.click()

    # Navigate back to the home timeline
    home_link = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'a[data-testid="AppTabBar_Home_Link"]')))
    home_link.click()


    # Wait for the reply textarea to appear and fill in a random message
    reply_textarea = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'div[role="textbox"]')))
    reply_textarea.send_keys("This is a randomly generated message")
    time.sleep(random.uniform(60, 900))  # Random pause for human-like behavior

    # Submit the reply
    tweet_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'div[data-testid="tweetButton"]')))
    tweet_button.click()

    # Navigate back to the home timeline
    home_link = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'a[data-testid="AppTabBar_Home_Link"]')))
    home_link.click()


load_dotenv()

your_email_or_username = os.getenv("TWITTER_USERNAME")
your_password = os.getenv("TWITTER_PASSWORD")
openai.api_key = os.getenv("OPEN_AIAPI")

service = Service("C:\Derivers\chromedriver_win32/chromedriver")

driver = webdriver.Chrome(service=service)
driver.get("https://twitter.com")

wait = WebDriverWait(driver,30)

# ... (previous code remains the same)

# Wait for a random period between 120 and 180 seconds, and scroll up and down
time.sleep(random.uniform(60, 180))
scroll_height = driver.execute_script("return document.body.scrollHeight")
driver.execute_script(f"window.scrollTo(0, {scroll_height // 2});")
time.sleep(2)
driver.execute_script("window.scrollTo(0, 0);")

# ... (previous code remains the same)

# Run the function 4 times every hour for 8 hours
for _ in range(8):
    for _ in range(4):
        interact_with_tweet(wait)
        # Wait for 15 minutes
        time.sleep(900)

driver.quit()
